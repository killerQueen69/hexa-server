<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hexa Admin Dashboard</title>
  <style>
    :root {
      --bg: #f3f4ef;
      --surface: #ffffff;
      --surface-alt: #f7f8f2;
      --line: #d7dbcf;
      --ink: #182016;
      --muted: #566353;
      --brand: #1f7a4f;
      --brand-strong: #145838;
      --danger: #b53a2f;
      --warn: #9e6f1a;
      --ok: #0f7b44;
      --shadow: 0 14px 32px rgba(18, 24, 15, 0.08);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "IBM Plex Sans", "Segoe UI", Tahoma, sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 500px at 100% -200px, #d9ecdf 0%, transparent 70%),
        radial-gradient(1000px 420px at -200px -220px, #f2ebd4 0%, transparent 70%),
        var(--bg);
      min-height: 100vh;
      padding: 20px;
    }

    .layout {
      max-width: 1500px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 340px minmax(0, 1fr);
      gap: 16px;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .stack { display: grid; gap: 12px; }

    h1 {
      margin: 0;
      font-size: 26px;
      letter-spacing: 0.2px;
    }

    h2 {
      margin: 0;
      font-size: 16px;
      letter-spacing: 0.15px;
    }

    .meta {
      font-size: 12px;
      color: var(--muted);
    }

    .muted { color: var(--muted); }

    label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    input, textarea, select, button {
      font: inherit;
    }

    input, textarea, select {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fcfdf9;
      color: var(--ink);
    }

    textarea { min-height: 64px; resize: vertical; }

    button {
      border: 1px solid transparent;
      border-radius: 10px;
      padding: 8px 11px;
      color: #fff;
      cursor: pointer;
      background: var(--brand);
    }

    button:hover { background: var(--brand-strong); }
    button.secondary { background: #3a5a49; }
    button.warn { background: var(--warn); }
    button.danger { background: var(--danger); }
    button.ghost {
      background: transparent;
      color: var(--ink);
      border-color: var(--line);
    }

    button.collapse-toggle {
      background: transparent;
      color: var(--muted);
      border-color: var(--line);
      padding: 4px 8px;
      font-size: 11px;
    }

    button.collapse-toggle:hover {
      background: #eef2e7;
      color: var(--ink);
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    .grid {
      display: grid;
      gap: 8px;
    }

    .grid.cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .grid.cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }

    .kpi-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .kpi {
      background: var(--surface-alt);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
    }

    .kpi .label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .kpi .value {
      margin-top: 6px;
      font-size: 22px;
      font-weight: 700;
    }

    .section-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .panel {
      display: grid;
      gap: 12px;
    }

    .table-wrap {
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 680px;
      font-size: 13px;
    }

    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid #e8ebe2;
      vertical-align: top;
    }

    th {
      background: #f4f7ef;
      color: #2f3f31;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .pill {
      display: inline-block;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.25px;
      border: 1px solid var(--line);
      background: #edf1e8;
      color: #2f3d2f;
    }

    .pill.ok { background: #dcf4e8; color: #0d6538; border-color: #c1e9d4; }
    .pill.warn { background: #f8eddb; color: #7e5712; border-color: #efd7b0; }
    .pill.bad { background: #f7e2df; color: #8a2d26; border-color: #efcbc6; }

    .code {
      font-family: Consolas, "Courier New", monospace;
      font-size: 12px;
      word-break: break-all;
    }

    .log {
      min-height: 180px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #0f1711;
      color: #d9efde;
      font-family: Consolas, "Courier New", monospace;
      font-size: 12px;
      padding: 10px;
      white-space: pre-wrap;
      overflow: auto;
    }

    .main-scroll {
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .card.is-collapsed {
      padding-bottom: 12px;
    }

    .devices-list {
      display: grid;
      gap: 12px;
      padding: 8px;
    }

    .device-card {
      display: grid;
      gap: 10px;
      border: 1px solid #dfe4d7;
      border-radius: 12px;
      background: #fbfcf8;
      padding: 12px;
    }

    .device-card-head {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
    }

    .device-title {
      margin: 0;
      font-size: 18px;
      line-height: 1.2;
    }

    .device-head-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .device-meta-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .device-meta-card {
      display: grid;
      gap: 3px;
      border: 1px solid #e3e8db;
      border-radius: 10px;
      background: #fff;
      padding: 8px;
      min-height: 72px;
    }

    .device-meta-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.35px;
      color: var(--muted);
    }

    .device-meta-value {
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
    }

    .device-main-grid,
    .device-footer-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .device-block {
      display: grid;
      gap: 8px;
      border: 1px solid #e3e8db;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }

    .device-block-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      color: var(--muted);
      font-weight: 700;
    }

    .relay-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .relay-card {
      display: grid;
      gap: 6px;
      border: 1px solid #e4e9dc;
      border-radius: 10px;
      background: #f8faf5;
      padding: 8px;
    }

    .relay-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .io-editor {
      display: grid;
      gap: 6px;
      margin-top: 4px;
    }

    .io-row {
      display: grid;
      gap: 6px;
      border: 1px solid #e2e7da;
      border-radius: 8px;
      padding: 6px;
      background: #f8faf5;
    }

    .io-row-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .io-row-grid {
      display: grid;
      gap: 6px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .io-inline-check {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .io-inline-check input {
      width: auto;
      margin: 0;
    }

    .conn-editor {
      display: grid;
      gap: 8px;
    }

    .conn-grid {
      display: grid;
      gap: 6px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .device-event {
      display: grid;
      gap: 4px;
      font-size: 12px;
    }

    .device-action-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .button-state-grid {
      display: grid;
      gap: 6px;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }

    .button-state-chip {
      display: grid;
      gap: 2px;
      border: 1px solid #dce2d3;
      border-radius: 8px;
      background: #f8faf5;
      padding: 6px 8px;
    }

    .button-state-chip.pressed {
      border-color: #efcbc6;
      background: #f7e2df;
    }

    .button-state-chip.released {
      border-color: #c1e9d4;
      background: #dcf4e8;
    }

    .button-state-chip.unknown {
      border-color: #efd7b0;
      background: #f8eddb;
    }

    @media (max-width: 1300px) {
      .layout { grid-template-columns: 1fr; }
      .kpi-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .grid.cols-3 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .device-meta-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .device-main-grid,
      .device-footer-grid { grid-template-columns: 1fr; }
    }

    @media (max-width: 760px) {
      body { padding: 12px; }
      .grid.cols-2,
      .grid.cols-3,
      .kpi-grid { grid-template-columns: 1fr; }
      table { min-width: 560px; }
      .devices-list { padding: 4px; }
      .device-meta-grid,
      .relay-grid,
      .conn-grid,
      .io-row-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="stack">
      <div class="card stack" data-card-id="about">
        <h1>Hexa Admin</h1>
        <div class="meta">Operations dashboard for runtime control, OTA, backups, and audit maintenance.</div>
        <div id="authState" class="pill">Not Authenticated</div>
      </div>

      <div class="card stack" data-card-id="connection">
        <h2>Connection</h2>
        <div>
          <label for="baseUrl">Server Base URL</label>
          <input id="baseUrl" />
        </div>
        <div>
          <label for="email">Email</label>
          <input id="email" type="email" />
        </div>
        <div>
          <label for="password">Password</label>
          <input id="password" type="password" />
        </div>
        <div class="row">
          <button id="loginBtn">Login</button>
          <button id="registerBtn" class="secondary">Register</button>
          <button id="refreshBtn" class="ghost">Refresh</button>
          <button id="logoutBtn" class="danger">Logout</button>
        </div>
        <div class="row">
          <button id="loadPrefsBtn" class="ghost">Load Prefs</button>
          <button id="savePrefsBtn" class="secondary">Save Prefs</button>
        </div>
        <div id="tokenView" class="code muted"></div>
      </div>

      <div class="card stack" data-card-id="ops-controls">
        <h2>Ops Controls</h2>
        <div class="row">
          <button id="reloadAllBtn">Reload Dashboard</button>
          <button id="loadMetricsBtn" class="secondary">Load /metrics</button>
        </div>
        <div class="row">
          <button id="runBackupBtn" class="warn">Run Encrypted Backup</button>
          <button id="runRestoreDrillBtn" class="warn">Run Restore Drill</button>
        </div>
        <div>
          <label for="restorePath">Restore Drill Backup Path (optional)</label>
          <input id="restorePath" placeholder="absolute-or-relative-path" />
        </div>
        <div class="row">
          <button id="simulateAlertsBtn" class="danger">Simulate Alerts</button>
          <button id="clearLogBtn" class="ghost">Clear Log</button>
        </div>
      </div>

      <div class="card stack" data-card-id="activity-log">
        <h2>Activity Log</h2>
        <div id="log" class="log"></div>
      </div>
    </aside>

    <main class="main-scroll">
      <section class="card panel" data-card-id="overview">
        <div class="section-title">
          <h2>Overview</h2>
          <div id="generatedAt" class="meta"></div>
        </div>
        <div id="kpis" class="kpi-grid"></div>
        <div id="overviewMeta" class="meta"></div>
      </section>

      <section class="card panel" data-card-id="users">
        <div class="section-title">
          <h2>Users</h2>
          <div class="meta">Role and activation maintenance</div>
        </div>
        <div id="usersTable" class="table-wrap"></div>
      </section>

      <section class="card panel" data-card-id="devices">
        <div class="section-title">
          <h2>Devices</h2>
          <div class="meta">Relay controls, ownership, token rotation</div>
        </div>
        <div class="row">
          <input id="claimCodeInput" placeholder="claim code (current logged user)" style="max-width: 250px;" />
          <button id="claimDeviceBtn" class="secondary">Claim By Code</button>
          <button id="refreshDevicesBtn" class="ghost">Refresh Devices</button>
        </div>
        <div id="devicesTable" class="table-wrap"></div>
      </section>

      <section class="card panel" data-card-id="ota-keys">
        <div class="section-title">
          <h2>OTA Signing Keys</h2>
          <div class="row">
            <button id="rotateSigningKeysBtn" class="secondary">Rotate Active/Next</button>
          </div>
        </div>
        <div class="grid cols-2">
          <div>
            <label for="signingKeyId">Key ID</label>
            <input id="signingKeyId" placeholder="ota-key-2026-q1" />
          </div>
          <div>
            <label for="signingKeyStatus">Status</label>
            <select id="signingKeyStatus">
              <option value="retired">retired</option>
              <option value="next">next</option>
              <option value="active">active</option>
            </select>
          </div>
          <div>
            <label for="signingSecretRef">Private Key Secret Ref</label>
            <input id="signingSecretRef" placeholder="env:OTA_ACTIVE_PRIVATE_KEY" />
          </div>
          <div class="row" style="align-items: end;">
            <button id="createSigningKeyBtn">Create Signing Key</button>
          </div>
        </div>
        <div>
          <label for="signingPublicPem">Public Key PEM</label>
          <textarea id="signingPublicPem" placeholder="-----BEGIN PUBLIC KEY-----"></textarea>
        </div>
        <div id="signingKeysTable" class="table-wrap"></div>
      </section>

      <section class="card panel" data-card-id="ota-releases">
        <div class="section-title">
          <h2>OTA Releases</h2>
          <div class="meta">Upload firmware or create release manually. Manifests/signatures are generated by server.</div>
        </div>
        <div class="grid cols-3">
          <div>
            <label for="releaseBinFile">Firmware .bin</label>
            <input id="releaseBinFile" type="file" accept=".bin,application/octet-stream" />
          </div>
          <div class="row" style="align-items: end;">
            <button id="uploadReleaseBtn" class="secondary">Upload Bin + Create Release</button>
          </div>
          <div>
            <label for="releaseMetadataJson">Metadata JSON (optional)</label>
            <input id="releaseMetadataJson" class="code" placeholder="{\"notes\":\"qa-2026-02-14\"}" />
          </div>
          <div>
            <label for="releaseModel">Model</label>
            <input id="releaseModel" value="hexa-mini-switch-v1" />
          </div>
          <div>
            <label for="releaseVersion">Version</label>
            <input id="releaseVersion" placeholder="1.2.3" />
          </div>
          <div>
            <label for="releaseSecurityVersion">Security Version</label>
            <input id="releaseSecurityVersion" type="number" min="0" value="1" />
          </div>
          <div>
            <label for="releaseChannel">Channel</label>
            <select id="releaseChannel">
              <option value="stable">stable</option>
              <option value="beta">beta</option>
              <option value="dev">dev</option>
            </select>
          </div>
          <div>
            <label for="releaseUrl">Artifact URL</label>
            <input id="releaseUrl" placeholder="https://updates.example.com/fw.bin" />
          </div>
          <div>
            <label for="releaseSizeBytes">Size Bytes</label>
            <input id="releaseSizeBytes" type="number" min="1" value="100000" />
          </div>
          <div>
            <label for="releaseSha">SHA-256</label>
            <input id="releaseSha" class="code" />
          </div>
          <div>
            <label for="releaseExpiresAt">Expires At (UTC ISO)</label>
            <input id="releaseExpiresAt" />
          </div>
          <div class="row" style="align-items: end;">
            <button id="createReleaseBtn">Create Signed Release</button>
          </div>
        </div>
        <div id="releasesTable" class="table-wrap"></div>
      </section>

      <section class="card panel" data-card-id="backup-runs">
        <div class="section-title">
          <h2>Backup Runs</h2>
          <div class="meta">Encrypted retention and restore drill tracking</div>
        </div>
        <div id="backupPolicy" class="meta"></div>
        <div id="backupRunsTable" class="table-wrap"></div>
      </section>

      <section class="card panel" data-card-id="audit-log">
        <div class="section-title">
          <h2>Audit Log</h2>
          <div class="row">
            <input id="auditFilterSource" placeholder="source filter" style="width: 170px;" />
            <input id="auditFilterAction" placeholder="action filter" style="width: 170px;" />
            <button id="loadAuditBtn" class="ghost">Reload Audit</button>
            <button id="clearAuditBtn" class="danger">Clear Audit</button>
          </div>
        </div>
        <div id="auditTable" class="table-wrap"></div>
      </section>

      <section class="card panel" data-card-id="raw-metrics">
        <div class="section-title">
          <h2>Raw Metrics</h2>
          <div class="meta">Prometheus exposition</div>
        </div>
        <pre id="metricsOutput" class="log"></pre>
      </section>
    </main>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const SESSION_STORAGE_KEY = "hexa_admin_dashboard_session_v2";
    const COLLAPSE_STORAGE_KEY = "hexa_admin_dashboard_collapsed_v1";

    const state = {
      accessToken: "",
      refreshToken: "",
      user: null,
      releases: [],
      users: [],
      devices: [],
      preferences: null,
      refreshPromise: null,
      collapsedCards: {},
      pendingDeviceActions: new Map(),
      realtimeSocket: null,
      realtimeAuthed: false,
      realtimeUrl: "",
      realtimeReconnectTimer: null,
      realtimeReconnectAttempt: 0,
      realtimeReloadTimer: null
    };
    const ADMIN_ONLY_CARD_IDS = new Set([
      "overview",
      "users",
      "ota-keys",
      "ota-releases",
      "backup-runs",
      "audit-log",
      "raw-metrics"
    ]);

    $("baseUrl").value = window.location.origin;
    $("releaseExpiresAt").value = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();

    const DASHBOARD_TZ_OFFSET_HOURS = 2;
    const DASHBOARD_TZ_LABEL = `UTC${DASHBOARD_TZ_OFFSET_HOURS >= 0 ? "+" : ""}${DASHBOARD_TZ_OFFSET_HOURS}`;

    function pad2(value) {
      return String(value).padStart(2, "0");
    }

    function toOffsetDate(dateLike) {
      const ms = dateLike instanceof Date ? dateLike.getTime() : new Date(dateLike).getTime();
      if (Number.isNaN(ms)) {
        return null;
      }
      return new Date(ms + DASHBOARD_TZ_OFFSET_HOURS * 60 * 60 * 1000);
    }

    function formatIsoWithOffset(value) {
      if (!value || typeof value !== "string") {
        return "-";
      }
      const shifted = toOffsetDate(value);
      if (!shifted) {
        return value;
      }
      return `${shifted.getUTCFullYear()}-${pad2(shifted.getUTCMonth() + 1)}-${pad2(shifted.getUTCDate())} ${pad2(shifted.getUTCHours())}:${pad2(shifted.getUTCMinutes())}:${pad2(shifted.getUTCSeconds())} ${DASHBOARD_TZ_LABEL}`;
    }

    function nowTs() {
      const shifted = toOffsetDate(new Date());
      if (!shifted) {
        return new Date().toISOString().slice(11, 19);
      }
      return `${pad2(shifted.getUTCHours())}:${pad2(shifted.getUTCMinutes())}:${pad2(shifted.getUTCSeconds())}`;
    }

    function nowIso() {
      return new Date().toISOString();
    }

    function log(line) {
      const el = $("log");
      el.textContent += `[${nowTs()}] ${line}\n`;
      el.scrollTop = el.scrollHeight;
    }

    function baseUrl() {
      return ($("baseUrl").value || "").trim().replace(/\/+$/, "");
    }

    function realtimeUrl() {
      const base = baseUrl();
      if (!base) {
        return "";
      }

      try {
        const parsed = new URL(base);
        const wsProtocol = parsed.protocol === "https:" ? "wss:" : "ws:";
        return `${wsProtocol}//${parsed.host}/ws/client`;
      } catch {
        return "";
      }
    }

    function clearRealtimeReconnectTimer() {
      if (state.realtimeReconnectTimer) {
        clearTimeout(state.realtimeReconnectTimer);
        state.realtimeReconnectTimer = null;
      }
    }

    function clearRealtimeReloadTimer() {
      if (state.realtimeReloadTimer) {
        clearTimeout(state.realtimeReloadTimer);
        state.realtimeReloadTimer = null;
      }
    }

    function queueRealtimeReload() {
      if (state.realtimeReloadTimer) {
        return;
      }
      state.realtimeReloadTimer = setTimeout(async () => {
        state.realtimeReloadTimer = null;
        try {
          if (isAdminUser()) {
            await Promise.all([loadDevices(), loadOverview()]);
          } else {
            await loadDevices();
          }
        } catch (error) {
          log(`Realtime sync failed: ${error.message}`);
        }
      }, 800);
    }

    function withDeviceByUid(deviceUid, updater) {
      if (!deviceUid) {
        return false;
      }
      for (const device of state.devices) {
        if (!device || device.device_uid !== deviceUid) {
          continue;
        }
        updater(device);
        return true;
      }
      return false;
    }

    function ensureDeviceButtonStates(device) {
      if (!device || typeof device !== "object") {
        return {};
      }
      if (!device.button_states || typeof device.button_states !== "object" || Array.isArray(device.button_states)) {
        device.button_states = {};
      }
      const states = device.button_states;
      const buttonCount = Number.isInteger(device.button_count) ? device.button_count : 0;
      for (let i = 0; i < buttonCount; i += 1) {
        const key = String(i);
        if (!states[key] || typeof states[key] !== "object") {
          states[key] = {
            state: "unknown",
            ts: null,
            source: null
          };
        }
      }
      return states;
    }

    function inferButtonState(eventName, previousState = "unknown") {
      const normalized = String(eventName || "").trim().toLowerCase();
      if (
        normalized === "press" ||
        normalized === "pressed" ||
        normalized === "down" ||
        normalized === "hold" ||
        normalized === "long_press" ||
        normalized === "long-press" ||
        normalized === "repeat"
      ) {
        return "pressed";
      }

      if (
        normalized === "release" ||
        normalized === "released" ||
        normalized === "up"
      ) {
        return "released";
      }

      return previousState;
    }

    function applyButtonStateFromEvent(device, inputIndex, eventName, ts, source = "device") {
      if (!device || !Number.isInteger(inputIndex)) {
        return;
      }
      const buttonCount = Number.isInteger(device.button_count) ? device.button_count : 0;
      if (inputIndex < 0 || inputIndex >= buttonCount) {
        return;
      }

      const states = ensureDeviceButtonStates(device);
      const key = String(inputIndex);
      const existing = states[key] && typeof states[key] === "object" ? states[key] : {};
      const previousState =
        existing.state === "pressed" || existing.state === "released"
          ? existing.state
          : "unknown";
      const nextState = inferButtonState(eventName, previousState);

      states[String(inputIndex)] = {
        state: nextState,
        ts: typeof ts === "string" ? ts : nowIso(),
        source
      };
    }

    function initializeDeviceButtonStates(device) {
      ensureDeviceButtonStates(device);
      const inputEvent = device && device.last_input_event && typeof device.last_input_event === "object"
        ? device.last_input_event
        : null;
      if (!inputEvent) {
        return;
      }
      const details = inputEvent.details && typeof inputEvent.details === "object" ? inputEvent.details : {};
      const inputIndex = Number.isInteger(details.input_index) ? details.input_index : null;
      const eventName = typeof details.event === "string" ? details.event : null;
      if (inputIndex === null || !eventName) {
        return;
      }
      applyButtonStateFromEvent(device, inputIndex, eventName, inputEvent.created_at, inputEvent.source || "device");
    }

    function applyRealtimePresence(message, online) {
      const uid = typeof message.device_uid === "string" ? message.device_uid : "";
      const ts = typeof message.ts === "string" ? message.ts : nowIso();
      const updated = withDeviceByUid(uid, (device) => {
        device.ws_online = online;
        if (online) {
          device.last_seen_at = ts;
        }
      });
      if (updated) {
        renderDevices(state.devices);
        queueRealtimeReload();
      } else {
        queueRealtimeReload();
      }
    }

    function applyRealtimeState(message) {
      const uid = typeof message.device_uid === "string" ? message.device_uid : "";
      const relays = Array.isArray(message.relays)
        ? message.relays.map((value) => Boolean(value))
        : null;
      if (!uid || !relays) {
        return;
      }

      const ts = typeof message.ts === "string" ? message.ts : nowIso();
      const updated = withDeviceByUid(uid, (device) => {
        const previousRelays = Array.isArray(device.relays) ? device.relays : [];
        const nextRelays = [];
        for (let i = 0; i < relays.length; i += 1) {
          const existing = previousRelays.find((item) => Number(item.relay_index) === i) || {};
          nextRelays.push({
            relay_index: i,
            relay_name: typeof existing.relay_name === "string" ? existing.relay_name : `Relay ${i + 1}`,
            is_on: relays[i]
          });
        }
        device.relays = nextRelays;
        device.last_seen_at = ts;
        device.ws_online = true;
      });

      if (updated) {
        renderDevices(state.devices);
      } else {
        queueRealtimeReload();
      }
    }

    function applyRealtimeInputEvent(message) {
      const uid = typeof message.device_uid === "string" ? message.device_uid : "";
      if (!uid) {
        return;
      }

      const ts = typeof message.ts === "string" ? message.ts : nowIso();
      const details = {
        input_index: Number.isInteger(message.input_index) ? message.input_index : null,
        input_type: typeof message.input_type === "string" ? message.input_type : null,
        event: typeof message.event === "string" ? message.event : null,
        duration_ms: Number.isFinite(Number(message.duration_ms)) ? Number(message.duration_ms) : null,
        ts
      };

      const updated = withDeviceByUid(uid, (device) => {
        device.last_seen_at = ts;
        device.ws_online = true;
        device.last_input_event = {
          source: "device",
          created_at: ts,
          details
        };
        if (Number.isInteger(details.input_index) && typeof details.event === "string") {
          applyButtonStateFromEvent(device, details.input_index, details.event, ts, "realtime");
        }
      });

      const eventName = typeof details.event === "string" ? details.event : "event";
      const inputIndex = Number.isInteger(details.input_index) ? `B${details.input_index}` : "B?";
      const durationText =
        Number.isFinite(details.duration_ms) && details.duration_ms > 0 ? ` (${details.duration_ms}ms)` : "";
      log(`Input event: ${uid} ${inputIndex} ${eventName}${durationText}`);

      if (updated) {
        renderDevices(state.devices);
      } else {
        queueRealtimeReload();
      }
    }

    function sendRealtimeAuth() {
      const socket = state.realtimeSocket;
      if (!socket || socket.readyState !== WebSocket.OPEN || !state.accessToken) {
        return;
      }
      socket.send(
        JSON.stringify({
          type: "auth",
          access_token: state.accessToken
        })
      );
    }

    function scheduleRealtimeReconnect(reason) {
      if (!state.user || !state.accessToken || state.realtimeReconnectTimer) {
        return;
      }
      const attempt = Math.min(state.realtimeReconnectAttempt, 5);
      const delayMs = Math.min(15000, 1000 * Math.pow(2, attempt));
      state.realtimeReconnectAttempt += 1;
      log(`Realtime disconnected (${reason}). Reconnecting in ${Math.round(delayMs / 1000)}s.`);
      state.realtimeReconnectTimer = setTimeout(() => {
        state.realtimeReconnectTimer = null;
        connectRealtime();
      }, delayMs);
    }

    function stopRealtime(options = {}) {
      const { silent = false } = options;
      clearRealtimeReconnectTimer();
      clearRealtimeReloadTimer();
      state.realtimeReconnectAttempt = 0;
      state.realtimeAuthed = false;

      const socket = state.realtimeSocket;
      state.realtimeSocket = null;
      state.realtimeUrl = "";

      if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
        socket.close(1000, "client_stop");
      }

      if (!silent) {
        log("Realtime channel stopped.");
      }
    }

    async function handleRealtimeMessage(socket, rawData) {
      let text = "";
      if (typeof rawData === "string") {
        text = rawData;
      } else if (rawData instanceof Blob) {
        text = await rawData.text();
      } else {
        return;
      }

      const message = safeParseJson(text, null);
      if (!message || typeof message !== "object") {
        return;
      }

      const type = typeof message.type === "string" ? message.type : "";
      if (!type) {
        return;
      }

      if (socket !== state.realtimeSocket) {
        return;
      }

      if (type === "auth_ok") {
        state.realtimeAuthed = true;
        state.realtimeReconnectAttempt = 0;
        log("Realtime auth successful.");
        return;
      }

      if (type === "auth_error") {
        state.realtimeAuthed = false;
        const code = typeof message.code === "string" ? message.code : "auth_error";
        log(`Realtime auth failed: ${code}`);
        if (code === "invalid_token" && state.refreshToken) {
          try {
            await refreshAccessToken();
            sendRealtimeAuth();
          } catch {
            scheduleRealtimeReconnect("auth_failed");
          }
        }
        return;
      }

      if (!state.realtimeAuthed) {
        return;
      }

      if (type === "device_state") {
        applyRealtimeState(message);
        return;
      }

      if (type === "input_event") {
        applyRealtimeInputEvent(message);
        return;
      }

      if (type === "device_online") {
        applyRealtimePresence(message, true);
        const uid = typeof message.device_uid === "string" ? message.device_uid : "device";
        log(`Device online: ${uid}`);
        return;
      }

      if (type === "device_offline") {
        applyRealtimePresence(message, false);
        const uid = typeof message.device_uid === "string" ? message.device_uid : "device";
        log(`Device offline: ${uid}`);
        return;
      }

      if (type === "ota_status") {
        const uid = typeof message.device_uid === "string" ? message.device_uid : "device";
        const eventType = typeof message.event_type === "string" ? message.event_type : "status";
        const status = typeof message.status === "string" ? message.status : "unknown";
        log(`OTA status: ${uid} ${eventType} ${status}`);
        return;
      }

      if (type === "cmd_ack" && message.ok === false) {
        const code = typeof message.code === "string" ? message.code : "command_failed";
        const detail = typeof message.message === "string" ? message.message : "";
        log(`Realtime command failed: ${code}${detail ? ` (${detail})` : ""}`);
      }
    }

    function connectRealtime(forceReconnect = false) {
      if (!state.user || !state.accessToken) {
        return;
      }

      const endpoint = realtimeUrl();
      if (!endpoint) {
        return;
      }

      const current = state.realtimeSocket;
      if (current) {
        const isSameUrl = state.realtimeUrl === endpoint;
        if (
          !forceReconnect &&
          isSameUrl &&
          (current.readyState === WebSocket.OPEN || current.readyState === WebSocket.CONNECTING)
        ) {
          return;
        }
        stopRealtime({ silent: true });
      }

      clearRealtimeReconnectTimer();
      state.realtimeUrl = endpoint;

      const socket = new WebSocket(endpoint);
      state.realtimeSocket = socket;
      state.realtimeAuthed = false;

      socket.addEventListener("open", () => {
        if (socket !== state.realtimeSocket) {
          return;
        }
        state.realtimeReconnectAttempt = 0;
        log("Realtime channel connected.");
        sendRealtimeAuth();
      });

      socket.addEventListener("message", (event) => {
        void handleRealtimeMessage(socket, event.data);
      });

      socket.addEventListener("close", (event) => {
        if (socket !== state.realtimeSocket) {
          return;
        }
        state.realtimeSocket = null;
        state.realtimeAuthed = false;
        if (state.user && state.accessToken) {
          scheduleRealtimeReconnect(`code ${event.code}`);
        }
      });

      socket.addEventListener("error", () => {
        if (socket !== state.realtimeSocket) {
          return;
        }
        log("Realtime channel error.");
      });
    }

    function safeParseJson(text, fallback) {
      if (!text) {
        return fallback;
      }
      try {
        return JSON.parse(text);
      } catch {
        return fallback;
      }
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    async function withDeviceActionLock(deviceId, fn) {
      const key = String(deviceId || "").trim();
      if (!key) {
        return fn();
      }

      const previous = state.pendingDeviceActions.get(key) || Promise.resolve();
      const run = previous
        .catch(() => undefined)
        .then(() => fn());

      state.pendingDeviceActions.set(
        key,
        run.finally(() => {
          if (state.pendingDeviceActions.get(key) === run) {
            state.pendingDeviceActions.delete(key);
          }
        })
      );

      return run;
    }

    function parseIsoMs(value) {
      if (typeof value !== "string" || !value.trim()) {
        return null;
      }
      const ms = new Date(value).getTime();
      return Number.isNaN(ms) ? null : ms;
    }

    function ageLabel(iso) {
      const ms = parseIsoMs(iso);
      if (ms === null) {
        return "-";
      }
      const ageSec = Math.max(0, Math.floor((Date.now() - ms) / 1000));
      if (ageSec < 60) {
        return `${ageSec}s ago`;
      }
      const ageMin = Math.floor(ageSec / 60);
      if (ageMin < 60) {
        return `${ageMin}m ago`;
      }
      const ageHr = Math.floor(ageMin / 60);
      if (ageHr < 24) {
        return `${ageHr}h ago`;
      }
      return `${Math.floor(ageHr / 24)}d ago`;
    }

    function isLikelyOnline(lastSeenAt) {
      const ms = parseIsoMs(lastSeenAt);
      if (ms === null) {
        return false;
      }
      return Date.now() - ms <= 90_000;
    }

    function persistCollapsedCards() {
      localStorage.setItem(COLLAPSE_STORAGE_KEY, JSON.stringify(state.collapsedCards || {}));
    }

    function loadCollapsedCards() {
      const stored = safeParseJson(localStorage.getItem(COLLAPSE_STORAGE_KEY), {});
      if (stored && typeof stored === "object" && !Array.isArray(stored)) {
        state.collapsedCards = stored;
      }
    }

    function persistSession() {
      const snapshot = {
        base_url: baseUrl(),
        email: $("email").value.trim(),
        user: state.user,
        access_token: state.accessToken,
        refresh_token: state.refreshToken
      };
      localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(snapshot));
    }

    function clearSession() {
      state.user = null;
      state.accessToken = "";
      state.refreshToken = "";
      state.preferences = null;
      persistSession();
    }

    function restoreSession() {
      const snapshot = safeParseJson(localStorage.getItem(SESSION_STORAGE_KEY), null);
      if (!snapshot || typeof snapshot !== "object") {
        return;
      }
      if (typeof snapshot.base_url === "string" && snapshot.base_url.trim()) {
        $("baseUrl").value = snapshot.base_url.trim();
      }
      if (typeof snapshot.email === "string" && snapshot.email.trim()) {
        $("email").value = snapshot.email.trim();
      }
      if (typeof snapshot.access_token === "string") {
        state.accessToken = snapshot.access_token;
      }
      if (typeof snapshot.refresh_token === "string") {
        state.refreshToken = snapshot.refresh_token;
      }
      if (snapshot.user && typeof snapshot.user === "object") {
        state.user = snapshot.user;
      }
    }

    function findDirectHeader(card) {
      for (const child of card.children) {
        if (child.classList && child.classList.contains("section-title")) {
          return child;
        }
      }
      return null;
    }

    function ensureCardHeader(card) {
      let header = findDirectHeader(card);
      if (header) {
        return header;
      }

      let title = null;
      for (const child of card.children) {
        if (child.tagName === "H1" || child.tagName === "H2") {
          title = child;
          break;
        }
      }
      if (!title) {
        return null;
      }

      header = document.createElement("div");
      header.className = "section-title";
      card.insertBefore(header, title);
      header.appendChild(title);
      return header;
    }

    function applyCardCollapsed(card, collapsed) {
      const header = findDirectHeader(card);
      for (const child of card.children) {
        if (child === header) {
          continue;
        }
        child.hidden = collapsed;
      }
      card.classList.toggle("is-collapsed", collapsed);
      const toggle = header ? header.querySelector(".collapse-toggle") : null;
      if (toggle) {
        toggle.textContent = collapsed ? "Expand" : "Collapse";
      }
    }

    function applyCollapseToAllCards() {
      document.querySelectorAll(".card").forEach((card, idx) => {
        const cardId = card.getAttribute("data-card-id") || `card-${idx + 1}`;
        applyCardCollapsed(card, Boolean(state.collapsedCards[cardId]));
      });
    }

    function setupCollapsibleCards() {
      document.querySelectorAll(".card").forEach((card, idx) => {
        const cardId = card.getAttribute("data-card-id") || `card-${idx + 1}`;
        const header = ensureCardHeader(card);
        if (!header) {
          return;
        }

        let toggle = header.querySelector(".collapse-toggle");
        if (!toggle) {
          toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "collapse-toggle";
          toggle.addEventListener("click", () => {
            const nextCollapsed = !Boolean(state.collapsedCards[cardId]);
            state.collapsedCards[cardId] = nextCollapsed;
            persistCollapsedCards();
            applyCardCollapsed(card, nextCollapsed);
          });
          header.appendChild(toggle);
        }

        applyCardCollapsed(card, Boolean(state.collapsedCards[cardId]));
      });
    }

    function setAuthState() {
      const badge = $("authState");
      if (!state.user) {
        badge.textContent = "Not Authenticated";
        badge.className = "pill";
        $("tokenView").textContent = "";
        applyRoleVisibility();
        return;
      }
      badge.textContent = `${state.user.email} (${state.user.role})`;
      badge.className = "pill ok";
      const tokenTail = state.accessToken ? state.accessToken.slice(-16) : "";
      $("tokenView").textContent = tokenTail
        ? `access_token: ...${tokenTail} | refresh loaded: ${state.refreshToken ? "yes" : "no"}`
        : "refresh loaded: yes";
      applyRoleVisibility();
    }

    function isAdminUser() {
      return Boolean(state.user && state.user.role === "admin");
    }

    function applyRoleVisibility() {
      const admin = isAdminUser();
      document.querySelectorAll(".card[data-card-id]").forEach((card) => {
        const cardId = card.getAttribute("data-card-id");
        if (!cardId || !ADMIN_ONLY_CARD_IDS.has(cardId)) {
          return;
        }
        card.style.display = admin ? "" : "none";
      });
    }

    function buildDeviceViewState() {
      const view = {};
      for (const device of state.devices) {
        if (!device || !device.device_uid) continue;
        view[device.device_uid] = {
          last_seen_at: device.last_seen_at || null,
          is_active: Boolean(device.is_active),
          relays: Array.isArray(device.relays)
            ? device.relays.map((relay) => ({
                relay_index: relay.relay_index,
                is_on: relay.is_on
              }))
            : []
        };
      }
      return view;
    }

    function applyPreferences(prefs) {
      if (!prefs || typeof prefs !== "object") return;
      const settings = prefs.dashboard_settings || {};
      if (typeof settings.base_url === "string" && settings.base_url.trim()) {
        $("baseUrl").value = settings.base_url.trim();
      }
      if (typeof settings.last_email === "string" && settings.last_email.trim()) {
        $("email").value = settings.last_email.trim();
      }
      if (typeof settings.audit_source_filter === "string") {
        $("auditFilterSource").value = settings.audit_source_filter;
      }
      if (typeof settings.audit_action_filter === "string") {
        $("auditFilterAction").value = settings.audit_action_filter;
      }
      if (typeof settings.restore_path === "string") {
        $("restorePath").value = settings.restore_path;
      }
      if (typeof settings.release_model === "string" && settings.release_model.trim()) {
        $("releaseModel").value = settings.release_model.trim();
      }
      if (typeof settings.release_channel === "string" && settings.release_channel.trim()) {
        $("releaseChannel").value = settings.release_channel.trim();
      }
      if (
        settings.collapsed_cards &&
        typeof settings.collapsed_cards === "object" &&
        !Array.isArray(settings.collapsed_cards)
      ) {
        state.collapsedCards = {
          ...state.collapsedCards,
          ...settings.collapsed_cards
        };
        persistCollapsedCards();
        applyCollapseToAllCards();
      }
    }

    async function loadPreferences() {
      const prefs = await api("/api/v1/preferences", { method: "GET" });
      state.preferences = prefs;
      applyPreferences(prefs);
      persistSession();
      log("Loaded user preferences.");
    }

    async function savePreferences() {
      const payload = {
        merge: true,
        dashboard_layout: {
          pinned_sections: ["overview", "users", "devices", "ota", "backup", "audit", "metrics"]
        },
        dashboard_settings: {
          base_url: baseUrl(),
          last_email: $("email").value.trim(),
          audit_source_filter: $("auditFilterSource").value || "",
          audit_action_filter: $("auditFilterAction").value || "",
          restore_path: $("restorePath").value || "",
          release_model: $("releaseModel").value || "",
          release_channel: $("releaseChannel").value || "stable",
          collapsed_cards: state.collapsedCards
        },
        device_view_state: buildDeviceViewState(),
        notification_settings: {
          alert_simulation_enabled: true
        }
      };
      const saved = await api("/api/v1/preferences", {
        method: "PATCH",
        body: JSON.stringify(payload)
      });
      state.preferences = saved;
      persistSession();
      log("Saved user preferences.");
    }

    function summarizeHtmlError(rawText) {
      const titleMatch = rawText.match(/<title>([^<]+)<\/title>/i);
      const rayMatch = rawText.match(/Cloudflare Ray ID:\s*<strong[^>]*>([^<]+)<\/strong>/i);
      const title = titleMatch ? titleMatch[1].replace(/\s+/g, " ").trim() : "";
      const rayId = rayMatch ? rayMatch[1].trim() : "";

      if (/cloudflare/i.test(rawText)) {
        const titlePart = title || "Cloudflare gateway timeout";
        const rayPart = rayId ? ` Ray ID: ${rayId}.` : "";
        return `${titlePart}.${rayPart} Origin timed out or returned 504 (often device ACK timeout).`;
      }

      const compact = rawText
        .replace(/<script[\s\S]*?<\/script>/gi, " ")
        .replace(/<style[\s\S]*?<\/style>/gi, " ")
        .replace(/<[^>]+>/g, " ")
        .replace(/\s+/g, " ")
        .trim();
      return compact.slice(0, 240);
    }

    function toApiError(response, body, rawText) {
      if (body && typeof body === "object" && body.message) {
        const detailsText =
          body.details && typeof body.details === "object"
            ? ` details=${JSON.stringify(body.details).slice(0, 180)}`
            : "";
        return new Error(`${body.code || "error"}: ${body.message}${detailsText}`);
      }
      if (rawText) {
        const htmlLike = /^\s*<!doctype html/i.test(rawText) || /^\s*<html/i.test(rawText);
        if (htmlLike) {
          return new Error(`HTTP ${response.status}: ${summarizeHtmlError(rawText)}`);
        }
        return new Error(`HTTP ${response.status}: ${rawText.slice(0, 240)}`);
      }
      return new Error(`HTTP ${response.status}`);
    }

    async function rawRequest(path, options = {}, authToken = "") {
      const headers = {
        ...(options.headers || {})
      };
      const hasBody = Object.prototype.hasOwnProperty.call(options, "body");
      const isFormDataBody = hasBody && typeof FormData !== "undefined" && options.body instanceof FormData;
      if (hasBody && !isFormDataBody && !headers["content-type"] && !headers["Content-Type"]) {
        headers["content-type"] = "application/json";
      }
      if (authToken) {
        headers.authorization = `Bearer ${authToken}`;
      }

      const response = await fetch(baseUrl() + path, {
        ...options,
        headers
      });
      const text = await response.text();
      const body = safeParseJson(text, {});
      return { response, body, text };
    }

    async function refreshAccessToken() {
      if (!state.refreshToken) {
        throw new Error("No refresh token loaded.");
      }
      if (state.refreshPromise) {
        return state.refreshPromise;
      }

      state.refreshPromise = (async () => {
        const { response, body, text } = await rawRequest("/api/v1/auth/refresh", {
          method: "POST",
          body: JSON.stringify({ refresh_token: state.refreshToken })
        });

        if (!response.ok) {
          throw toApiError(response, body, text);
        }

        if (!body.access_token) {
          throw new Error("refresh_failed: Missing access_token.");
        }

        state.accessToken = body.access_token;
        state.refreshToken = body.refresh_token || state.refreshToken;
        setAuthState();
        persistSession();
        log("Access token refreshed.");
        if (state.user) {
          if (state.realtimeSocket && state.realtimeSocket.readyState === WebSocket.OPEN) {
            sendRealtimeAuth();
          } else {
            connectRealtime();
          }
        }
      })();

      try {
        await state.refreshPromise;
      } finally {
        state.refreshPromise = null;
      }
    }

    async function api(path, options = {}, allowRetry = true) {
      const first = await rawRequest(path, options, state.accessToken);
      if (first.response.ok) {
        return first.body;
      }

      const isAuthPath = path.startsWith("/api/v1/auth/");
      const canRetry =
        allowRetry &&
        first.response.status === 401 &&
        Boolean(state.refreshToken) &&
        !isAuthPath;

      if (canRetry) {
        try {
          await refreshAccessToken();
          const retry = await rawRequest(path, options, state.accessToken);
          if (!retry.response.ok) {
            throw toApiError(retry.response, retry.body, retry.text);
          }
          return retry.body;
        } catch (error) {
          clearSession();
          setAuthState();
          throw error instanceof Error
            ? error
            : new Error("unauthorized: Authentication required.");
        }
      }

      throw toApiError(first.response, first.body, first.text);
    }

    function renderKpis(overview) {
      const devices = overview.fleet?.devices || {};
      const users = overview.fleet?.users || {};
      const schedules = overview.schedules || {};
      const ota = overview.ota || {};

      const cards = [
        ["Devices Total", devices.total || 0],
        ["Devices Online", devices.online_estimate || 0],
        ["Users Active", users.active || 0],
        ["Schedules Enabled", schedules.enabled || 0],
        ["OTA Active Releases", ota.active_releases || 0],
        ["OTA Failed Reports 24h", ota.failed_reports_24h || 0],
        ["Claimed Devices", devices.claimed || 0],
        ["Unclaimed Devices", devices.unclaimed || 0]
      ];

      $("kpis").innerHTML = cards.map(([label, value]) =>
        `<div class="kpi"><div class="label">${label}</div><div class="value">${value}</div></div>`
      ).join("");
      $("generatedAt").textContent = `Generated ${formatIsoWithOffset(overview.generated_at)} (${DASHBOARD_TZ_LABEL})`;
      $("overviewMeta").textContent = `REST ${overview.api_versions?.rest || "v1"} | WS ${overview.api_versions?.ws || "v1"} | Deprecation window ${overview.api_versions?.deprecation_window_days || 0} days`;
      const policy = overview.backup?.policy || {};
      $("backupPolicy").textContent = `Backup dir: ${policy.output_dir || ""} | retention: ${policy.retention_count || 0} | encrypted: ${policy.encryption_configured ? "yes" : "no"} | RPO: ${policy.rpo_minutes || 0} min | RTO: ${policy.rto_minutes || 0} min`;
    }

    function renderUsers(users) {
      const rows = users.map((u) => `
        <tr>
          <td>${escapeHtml(u.email)}</td>
          <td><input data-user-name="${escapeHtml(u.id)}" value="${escapeHtml(u.name || "")}" /></td>
          <td>
            <select data-user-role="${escapeHtml(u.id)}">
              <option value="user" ${u.role === "user" ? "selected" : ""}>user</option>
              <option value="admin" ${u.role === "admin" ? "selected" : ""}>admin</option>
            </select>
          </td>
          <td>${escapeHtml(u.device_count)}</td>
          <td><input type="checkbox" data-user-active="${escapeHtml(u.id)}" ${u.is_active ? "checked" : ""} /></td>
          <td>
            <div class="row">
              <button data-user-save="${escapeHtml(u.id)}">Save</button>
              <button data-user-delete="${escapeHtml(u.id)}" class="danger" ${state.user?.id === u.id ? "disabled" : ""}>Delete</button>
            </div>
          </td>
        </tr>
      `).join("");

      $("usersTable").innerHTML = `
        <table>
          <thead><tr><th>Email</th><th>Name</th><th>Role</th><th>Devices</th><th>Active</th><th>Action</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    function describeInputConfigRow(row) {
      if (!row || typeof row !== "object") {
        return "-";
      }
      const inputIdx = Number.isInteger(row.input_index) ? `B${row.input_index}` : "B?";
      const inputType = typeof row.input_type === "string" ? row.input_type : "unknown";
      const invert = row.invert_input === true ? "invert" : "";
      const hold = Number.isInteger(row.hold_seconds) ? `hold:${row.hold_seconds}s` : "";
      const rocker = typeof row.rocker_mode === "string" ? row.rocker_mode : "";

      if (row.linked !== true) {
        const extras = [invert, hold, rocker].filter(Boolean).join(" ");
        return extras ? `${inputIdx} ${inputType} (unlinked, ${extras})` : `${inputIdx} ${inputType} (unlinked)`;
      }

      const targetRelay = Number.isInteger(row.target_relay_index) ? `R${row.target_relay_index}` : "R?";
      const linkedExtras = [invert, hold, rocker].filter(Boolean).join(" ");
      return linkedExtras
        ? `${inputIdx} ${inputType} -> ${targetRelay} (${linkedExtras})`
        : `${inputIdx} ${inputType} -> ${targetRelay}`;
    }

    function normalizedInputConfig(device) {
      const buttonCount = Number.isInteger(device?.button_count) ? device.button_count : 0;
      const relayCount = Number.isInteger(device?.relay_count) ? device.relay_count : 0;
      const existingRows = Array.isArray(device?.input_config) ? device.input_config : [];
      const byIndex = new Map();
      for (const row of existingRows) {
        if (!row || typeof row !== "object") {
          continue;
        }
        if (!Number.isInteger(row.input_index)) {
          continue;
        }
        byIndex.set(row.input_index, row);
      }

      const normalized = [];
      for (let i = 0; i < buttonCount; i += 1) {
        const row = byIndex.get(i) || {};
        const inputType = row.input_type === "rocker_switch" ? "rocker_switch" : "push_button";
        const linked = row.linked !== false;
        const relayFallback = relayCount > 0 ? Math.min(i, relayCount - 1) : null;
        const targetRelay = Number.isInteger(row.target_relay_index)
          ? Math.min(Math.max(Number(row.target_relay_index), 0), Math.max(relayCount - 1, 0))
          : relayFallback;

        normalized.push({
          input_index: i,
          input_type: inputType,
          linked: relayCount > 0 ? linked : false,
          target_relay_index: relayCount > 0 && linked ? targetRelay : null,
          rocker_mode: inputType === "rocker_switch"
            ? (row.rocker_mode === "follow_position" ? "follow_position" : "edge_toggle")
            : null,
          invert_input: row.invert_input === true,
          hold_seconds: inputType === "push_button" && Number.isInteger(row.hold_seconds)
            ? Number(row.hold_seconds)
            : null
        });
      }

      return normalized;
    }

    function asConfigObject(value) {
      if (!value || typeof value !== "object" || Array.isArray(value)) {
        return {};
      }
      return value;
    }

    function normalizeConnectivityMode(value) {
      if (typeof value !== "string") {
        return "cloud_ws";
      }
      const normalized = value.trim().toLowerCase();
      if (normalized === "local_mqtt" || normalized === "mqtt" || normalized === "ha") {
        return "local_mqtt";
      }
      return "cloud_ws";
    }

    function normalizedConnectivityConfig(device) {
      const configRoot = asConfigObject(device?.config);
      const connectivity = asConfigObject(configRoot.connectivity || configRoot.connection);
      const mqtt = asConfigObject(connectivity.mqtt || connectivity.local_mqtt || configRoot.local_mqtt);
      const rawPort = Number.parseInt(String(mqtt.port ?? ""), 10);
      const port = Number.isInteger(rawPort) && rawPort > 0 && rawPort <= 65535 ? rawPort : 1883;
      const mode = normalizeConnectivityMode(
        connectivity.mode || connectivity.connection_mode || connectivity.transport_mode
      );
      return {
        mode,
        mqtt: {
          enabled: typeof mqtt.enabled === "boolean" ? mqtt.enabled : true,
          host: typeof mqtt.host === "string" ? mqtt.host.trim() : "",
          port,
          username: typeof mqtt.username === "string"
            ? mqtt.username
            : (typeof mqtt.user === "string" ? mqtt.user : ""),
          password: typeof mqtt.password === "string"
            ? mqtt.password
            : (typeof mqtt.pass === "string" ? mqtt.pass : ""),
          discovery_prefix: typeof mqtt.discovery_prefix === "string" && mqtt.discovery_prefix.trim()
            ? mqtt.discovery_prefix.trim()
            : "homeassistant",
          base_topic: typeof mqtt.base_topic === "string" && mqtt.base_topic.trim()
            ? mqtt.base_topic.trim()
            : "d"
        }
      };
    }

    function buildConnectivityEditor(device) {
      const cfg = normalizedConnectivityConfig(device);
      const canEdit = isAdminUser() || Boolean(device?.is_owner);
      const mode = cfg.mode === "local_mqtt" ? "local_mqtt" : "cloud_ws";
      const mqttEditable = canEdit && mode === "local_mqtt";
      const lockAttr = canEdit ? "" : ' data-conn-lock="1"';
      const modeLockAttr = canEdit ? "" : ' data-conn-lock="1"';
      return `
        <div class="conn-editor">
          <div class="conn-grid">
            <div>
              <label>Control Mode</label>
              <select data-conn-mode="${escapeHtml(device.id)}"${modeLockAttr} ${canEdit ? "" : "disabled"}>
                <option value="cloud_ws" ${mode === "cloud_ws" ? "selected" : ""}>Cloud (Hexa Server)</option>
                <option value="local_mqtt" ${mode === "local_mqtt" ? "selected" : ""}>Local MQTT (Home Assistant)</option>
              </select>
            </div>
            <div>
              <label>MQTT Port</label>
              <input data-conn-port="${escapeHtml(device.id)}" type="number" min="1" max="65535" value="${escapeHtml(cfg.mqtt.port)}"${lockAttr} ${mqttEditable ? "" : "disabled"} />
            </div>
            <div>
              <label>MQTT Host</label>
              <input data-conn-host="${escapeHtml(device.id)}" value="${escapeHtml(cfg.mqtt.host)}"${lockAttr} ${mqttEditable ? "" : "disabled"} />
            </div>
            <div>
              <label>MQTT Username</label>
              <input data-conn-username="${escapeHtml(device.id)}" value="${escapeHtml(cfg.mqtt.username)}"${lockAttr} ${mqttEditable ? "" : "disabled"} />
            </div>
            <div>
              <label>MQTT Password</label>
              <input data-conn-password="${escapeHtml(device.id)}" type="password" value="${escapeHtml(cfg.mqtt.password)}"${lockAttr} ${mqttEditable ? "" : "disabled"} />
            </div>
            <div>
              <label>Discovery Prefix</label>
              <input data-conn-discovery="${escapeHtml(device.id)}" value="${escapeHtml(cfg.mqtt.discovery_prefix)}"${lockAttr} ${mqttEditable ? "" : "disabled"} />
            </div>
            <div>
              <label>Base Topic</label>
              <input data-conn-base-topic="${escapeHtml(device.id)}" value="${escapeHtml(cfg.mqtt.base_topic)}"${lockAttr} ${mqttEditable ? "" : "disabled"} />
            </div>
            <label class="io-inline-check">
              <input data-conn-enabled="${escapeHtml(device.id)}" type="checkbox" ${cfg.mqtt.enabled ? "checked" : ""}${lockAttr} ${mqttEditable ? "" : "disabled"} />
              enable local MQTT
            </label>
          </div>
          ${canEdit
            ? '<div class="meta">Changing mode may restart device networking briefly.</div>'
            : '<div class="meta">Read-only. Only owner/admin can change connectivity mode.</div>'}
        </div>
      `;
    }

    function syncConnectivityControls(deviceId) {
      const modeEl = document.querySelector(`[data-conn-mode="${deviceId}"]`);
      if (!(modeEl instanceof HTMLSelectElement)) {
        return;
      }
      if (modeEl.dataset.connLock === "1") {
        return;
      }

      const localMode = modeEl.value === "local_mqtt";
      const selectors = [
        `[data-conn-enabled="${deviceId}"]`,
        `[data-conn-host="${deviceId}"]`,
        `[data-conn-port="${deviceId}"]`,
        `[data-conn-username="${deviceId}"]`,
        `[data-conn-password="${deviceId}"]`,
        `[data-conn-discovery="${deviceId}"]`,
        `[data-conn-base-topic="${deviceId}"]`
      ];
      for (const selector of selectors) {
        const field = document.querySelector(selector);
        if (!(field instanceof HTMLInputElement || field instanceof HTMLSelectElement)) {
          continue;
        }
        if (field.dataset.connLock === "1") {
          field.disabled = true;
          continue;
        }
        field.disabled = !localMode;
      }
    }

    function collectConnectivityConfigFromEditor(device) {
      const deviceId = device?.id;
      if (!deviceId) {
        throw new Error("Device id is required.");
      }

      const modeEl = document.querySelector(`[data-conn-mode="${deviceId}"]`);
      const enabledEl = document.querySelector(`[data-conn-enabled="${deviceId}"]`);
      const hostEl = document.querySelector(`[data-conn-host="${deviceId}"]`);
      const portEl = document.querySelector(`[data-conn-port="${deviceId}"]`);
      const usernameEl = document.querySelector(`[data-conn-username="${deviceId}"]`);
      const passwordEl = document.querySelector(`[data-conn-password="${deviceId}"]`);
      const discoveryEl = document.querySelector(`[data-conn-discovery="${deviceId}"]`);
      const baseTopicEl = document.querySelector(`[data-conn-base-topic="${deviceId}"]`);

      if (!(modeEl instanceof HTMLSelectElement)) throw new Error("Missing connectivity mode control.");
      if (!(enabledEl instanceof HTMLInputElement)) throw new Error("Missing MQTT enabled control.");
      if (!(hostEl instanceof HTMLInputElement)) throw new Error("Missing MQTT host control.");
      if (!(portEl instanceof HTMLInputElement)) throw new Error("Missing MQTT port control.");
      if (!(usernameEl instanceof HTMLInputElement)) throw new Error("Missing MQTT username control.");
      if (!(passwordEl instanceof HTMLInputElement)) throw new Error("Missing MQTT password control.");
      if (!(discoveryEl instanceof HTMLInputElement)) throw new Error("Missing discovery prefix control.");
      if (!(baseTopicEl instanceof HTMLInputElement)) throw new Error("Missing base topic control.");

      const mode = modeEl.value === "local_mqtt" ? "local_mqtt" : "cloud_ws";
      const host = hostEl.value.trim();
      const portParsed = Number.parseInt(portEl.value, 10);
      if (!Number.isInteger(portParsed) || portParsed < 1 || portParsed > 65535) {
        throw new Error("MQTT port must be between 1 and 65535.");
      }

      if (mode === "local_mqtt" && !host) {
        throw new Error("MQTT host is required in local MQTT mode.");
      }

      return {
        mode,
        mqtt: {
          enabled: enabledEl.checked,
          host,
          port: portParsed,
          username: usernameEl.value,
          password: passwordEl.value,
          discovery_prefix: discoveryEl.value.trim() || "homeassistant",
          base_topic: baseTopicEl.value.trim() || "d"
        }
      };
    }

    function mergeConnectivityConfig(device, connectivityPayload) {
      const root = asConfigObject(safeParseJson(JSON.stringify(asConfigObject(device?.config)), {}));
      const existingConnectivity = asConfigObject(root.connectivity);
      const existingMqtt = asConfigObject(existingConnectivity.mqtt);
      root.connectivity = {
        ...existingConnectivity,
        mode: connectivityPayload.mode,
        mqtt: {
          ...existingMqtt,
          ...connectivityPayload.mqtt
        }
      };
      return root;
    }

    function buildInputConfigEditor(device) {
      const relayNames = Array.isArray(device?.relay_names) ? device.relay_names : [];
      const relayCount = Number.isInteger(device?.relay_count) ? device.relay_count : 0;
      const normalized = normalizedInputConfig(device);

      if (!normalized.length) {
        return '<div class="muted">no buttons on this device</div>';
      }

      const rows = normalized.map((row) => {
        const key = `${device.id}:${row.input_index}`;
        const inputType = row.input_type === "rocker_switch" ? "rocker_switch" : "push_button";
        const linked = row.linked === true && relayCount > 0;
        const follow = inputType === "rocker_switch" && row.rocker_mode === "follow_position";
        const targetRelay = Number.isInteger(row.target_relay_index) ? row.target_relay_index : 0;

        const relayOptions = relayCount > 0
          ? Array.from({ length: relayCount }, (_, relayIndex) => {
              const relayName = typeof relayNames[relayIndex] === "string"
                ? relayNames[relayIndex]
                : `Relay ${relayIndex + 1}`;
              const selected = targetRelay === relayIndex ? "selected" : "";
              return `<option value="${relayIndex}" ${selected}>R${relayIndex} - ${escapeHtml(relayName)}</option>`;
            }).join("")
          : '<option value="">No relays</option>';

        const targetDisabled = relayCount === 0 || !linked;
        const followDisabled = inputType !== "rocker_switch";

        return `
          <div class="io-row">
            <div class="io-row-head">
              <strong>B${escapeHtml(row.input_index)}</strong>
              <span class="meta">${escapeHtml(describeInputConfigRow(row))}</span>
            </div>
            <div class="io-row-grid">
              <div>
                <label>Input Type</label>
                <select data-io-type="${escapeHtml(key)}">
                  <option value="push_button" ${inputType === "push_button" ? "selected" : ""}>push_button</option>
                  <option value="rocker_switch" ${inputType === "rocker_switch" ? "selected" : ""}>rocker_switch</option>
                </select>
              </div>
              <div>
                <label>Target Relay</label>
                <select data-io-target="${escapeHtml(key)}" ${targetDisabled ? "disabled" : ""}>
                  ${relayOptions}
                </select>
              </div>
            </div>
            <div class="row">
              <label class="io-inline-check">
                <input type="checkbox" data-io-linked="${escapeHtml(key)}" ${linked ? "checked" : ""} ${relayCount === 0 ? "disabled" : ""} />
                linked to relay
              </label>
              <label class="io-inline-check">
                <input type="checkbox" data-io-follow="${escapeHtml(key)}" ${follow ? "checked" : ""} ${followDisabled ? "disabled" : ""} />
                follow mode (rocker)
              </label>
            </div>
          </div>
        `;
      }).join("");

      return `<div class="io-editor">${rows}</div>`;
    }

    function syncInputRowControls(key) {
      const typeEl = document.querySelector(`[data-io-type="${key}"]`);
      const linkedEl = document.querySelector(`[data-io-linked="${key}"]`);
      const targetEl = document.querySelector(`[data-io-target="${key}"]`);
      const followEl = document.querySelector(`[data-io-follow="${key}"]`);

      if (!(typeEl instanceof HTMLSelectElement)) return;
      if (!(linkedEl instanceof HTMLInputElement)) return;
      if (!(targetEl instanceof HTMLSelectElement)) return;
      if (!(followEl instanceof HTMLInputElement)) return;

      const isRocker = typeEl.value === "rocker_switch";
      if (!isRocker) {
        followEl.checked = false;
      }
      followEl.disabled = !isRocker;

      const hasRelay = targetEl.options.length > 0 && targetEl.value !== "";
      targetEl.disabled = !linkedEl.checked || !hasRelay;
    }

    function collectInputConfigFromEditor(device) {
      const relayCount = Number.isInteger(device?.relay_count) ? device.relay_count : 0;
      const normalized = normalizedInputConfig(device);
      const byIndex = new Map(normalized.map((row) => [row.input_index, row]));

      const payload = [];
      for (let i = 0; i < normalized.length; i += 1) {
        const key = `${device.id}:${i}`;
        const typeEl = document.querySelector(`[data-io-type="${key}"]`);
        const linkedEl = document.querySelector(`[data-io-linked="${key}"]`);
        const targetEl = document.querySelector(`[data-io-target="${key}"]`);
        const followEl = document.querySelector(`[data-io-follow="${key}"]`);

        if (!(typeEl instanceof HTMLSelectElement)) {
          throw new Error(`Missing type control for button ${i}`);
        }
        if (!(linkedEl instanceof HTMLInputElement)) {
          throw new Error(`Missing linked control for button ${i}`);
        }
        if (!(targetEl instanceof HTMLSelectElement)) {
          throw new Error(`Missing relay control for button ${i}`);
        }
        if (!(followEl instanceof HTMLInputElement)) {
          throw new Error(`Missing follow control for button ${i}`);
        }

        const current = byIndex.get(i) || {};
        const inputType = typeEl.value === "rocker_switch" ? "rocker_switch" : "push_button";
        const linked = relayCount > 0 ? linkedEl.checked : false;
        const targetRelayParsed = Number.parseInt(targetEl.value, 10);
        const targetRelay =
          linked && relayCount > 0 && Number.isInteger(targetRelayParsed)
            ? Math.min(Math.max(targetRelayParsed, 0), relayCount - 1)
            : null;

        payload.push({
          input_index: i,
          input_type: inputType,
          linked,
          target_relay_index: targetRelay,
          rocker_mode: inputType === "rocker_switch"
            ? (followEl.checked ? "follow_position" : "edge_toggle")
            : null,
          invert_input: current.invert_input === true,
          hold_seconds: inputType === "push_button" && Number.isInteger(current.hold_seconds)
            ? Number(current.hold_seconds)
            : null
        });
      }

      return payload;
    }

    function summarizeLastAction(device) {
      const action = device && device.last_action && typeof device.last_action === "object" ? device.last_action : null;
      if (!action) {
        return "-";
      }
      const actionName = typeof action.action === "string" ? action.action : "unknown";
      const source = typeof action.source === "string" ? action.source : "n/a";
      const at = typeof action.created_at === "string" ? formatIsoWithOffset(action.created_at) : "-";
      const details = action.details && typeof action.details === "object" ? action.details : {};
      const relayPart = Number.isInteger(details.relay_index) ? ` r${details.relay_index}` : "";
      const commandPart = typeof details.action === "string" ? ` ${details.action}` : "";
      const suffix = [relayPart, commandPart].join("").trim();
      return `${actionName}${suffix ? ` (${suffix})` : ""} [${source}] ${at !== "-" ? at : ""}`.trim();
    }

    function summarizeLastInputEvent(device) {
      const inputEvent = device && device.last_input_event && typeof device.last_input_event === "object"
        ? device.last_input_event
        : null;
      if (!inputEvent) {
        return "-";
      }
      const details = inputEvent.details && typeof inputEvent.details === "object" ? inputEvent.details : {};
      const idx = Number.isInteger(details.input_index) ? `B${details.input_index}` : "B?";
      const eventName = typeof details.event === "string" ? details.event : "event";
      const duration = Number.isFinite(Number(details.duration_ms)) ? `${Number(details.duration_ms)}ms` : "";
      const at = typeof inputEvent.created_at === "string" ? formatIsoWithOffset(inputEvent.created_at) : "-";
      return `${idx} ${eventName}${duration ? ` (${duration})` : ""} ${at !== "-" ? at : ""}`.trim();
    }

    function renderButtonStates(device) {
      const buttonCount = Number.isInteger(device?.button_count) ? device.button_count : 0;
      if (buttonCount <= 0) {
        return '<div class="muted">No buttons configured.</div>';
      }

      const states = ensureDeviceButtonStates(device);
      const chips = [];
      for (let i = 0; i < buttonCount; i += 1) {
        const row = states[String(i)] && typeof states[String(i)] === "object" ? states[String(i)] : {};
        const rawState = row.state === "pressed" || row.state === "released" ? row.state : "unknown";
        const stateLabel = rawState === "pressed" ? "Pressed" : rawState === "released" ? "Released" : "Unknown";
        const updatedAt = typeof row.ts === "string" ? formatIsoWithOffset(row.ts) : "-";
        chips.push(`
          <div class="button-state-chip ${rawState}">
            <strong>B${escapeHtml(i)}</strong>
            <span>${escapeHtml(stateLabel)}</span>
            <div class="meta">${updatedAt !== "-" ? escapeHtml(updatedAt) : "No signal yet"}</div>
          </div>
        `);
      }

      return `<div class="button-state-grid">${chips.join("")}</div>`;
    }

    function renderDevices(devices) {
      if (!Array.isArray(devices) || devices.length === 0) {
        $("devicesTable").innerHTML = `
          <div class="devices-list">
            <div class="device-card">
              <div class="muted">No devices found.</div>
            </div>
          </div>
        `;
        return;
      }

      const cards = devices.map((d) => {
        const admin = isAdminUser();
        initializeDeviceButtonStates(d);
        const relayNames = Array.isArray(d.relay_names) ? d.relay_names : [];
        const relayRows = Array.isArray(d.relays) && d.relays.length > 0
          ? d.relays
          : Array.from({ length: Math.max(Number(d.relay_count) || 0, 0) }, (_, relayIndex) => ({
              relay_index: relayIndex,
              relay_name: typeof relayNames[relayIndex] === "string" ? relayNames[relayIndex] : null,
              is_on: null
            }));

        const relayControls = relayRows.map((r) => {
          const relayIndex = Number(r.relay_index);
          const relayName = typeof relayNames[relayIndex] === "string"
            ? relayNames[relayIndex]
            : `Relay ${relayIndex + 1}`;
          const relayState = r.is_on === true ? "ON" : r.is_on === false ? "OFF" : "UNKNOWN";
          const relayBadgeClass = r.is_on === true ? "ok" : r.is_on === false ? "warn" : "";
          return `
            <div class="relay-card">
              <div class="relay-head">
                <strong>${escapeHtml(relayName)}</strong>
                <span class="pill ${relayBadgeClass}">R${escapeHtml(relayIndex)}:${escapeHtml(relayState)}</span>
              </div>
              <div class="device-action-row">
                <button data-relay="${escapeHtml(d.id)}:${escapeHtml(relayIndex)}:on">On</button>
                <button data-relay="${escapeHtml(d.id)}:${escapeHtml(relayIndex)}:off" class="secondary">Off</button>
                <button data-relay="${escapeHtml(d.id)}:${escapeHtml(relayIndex)}:toggle" class="warn">Toggle</button>
              </div>
            </div>
          `;
        }).join("");

        const inputEditor = buildInputConfigEditor(d);
        const connectivityEditor = buildConnectivityEditor(d);
        const connectivityConfig = normalizedConnectivityConfig(d);
        const buttonStates = renderButtonStates(d);

        const wsOnline = typeof d.ws_online === "boolean" ? d.ws_online : null;
        const online = wsOnline === null
          ? Boolean(d.is_active) && isLikelyOnline(d.last_seen_at)
          : wsOnline;
        const statusBadge = !d.is_active
          ? '<span class="pill bad">inactive</span>'
          : online
            ? '<span class="pill ok">online</span>'
            : '<span class="pill warn">stale/offline</span>';
        const ownershipBadge = d.owner_user_id
          ? '<span class="pill ok">claimed</span>'
          : '<span class="pill warn">unclaimed</span>';

        return `
          <article class="device-card">
            <div class="device-card-head">
              <div>
                <h3 class="device-title">${escapeHtml(d.name)}</h3>
                <div class="device-head-badges">
                  ${statusBadge}
                  ${ownershipBadge}
                  <span class="pill">${escapeHtml(d.device_class || "-")}</span>
                </div>
                <div class="meta code">${escapeHtml(d.device_uid)}</div>
                <div class="meta">model: ${escapeHtml(d.model || "-")}</div>
              </div>
            </div>

            <div class="device-meta-grid">
              <div class="device-meta-card">
                <div class="device-meta-label">Ownership</div>
                <div class="device-meta-value">${escapeHtml(d.owner_email || "unclaimed")}</div>
                <div class="meta code">owner_id: ${escapeHtml(d.owner_user_id || "-")}</div>
                <div class="meta code">claim_code: ${escapeHtml(d.claim_code || "-")}</div>
              </div>
              <div class="device-meta-card">
                <div class="device-meta-label">Firmware</div>
                <div class="device-meta-value">fw: ${escapeHtml(d.firmware_version || "-")}</div>
                <div class="meta">ota: ${escapeHtml(d.ota_channel)}/${escapeHtml(d.ota_security_version)}</div>
              </div>
              <div class="device-meta-card">
                <div class="device-meta-label">Connectivity</div>
                <div class="device-meta-value">last_seen: ${escapeHtml(formatIsoWithOffset(d.last_seen_at))}</div>
                <div class="meta">age: ${escapeHtml(ageLabel(d.last_seen_at))}</div>
                <div class="meta">ip: ${escapeHtml(d.last_ip || "-")}</div>
                <div class="meta">mode: ${escapeHtml(connectivityConfig.mode)}</div>
                <div class="meta">broker: ${escapeHtml(connectivityConfig.mqtt.host || "-")}:${escapeHtml(connectivityConfig.mqtt.port)}</div>
              </div>
              <div class="device-meta-card">
                <div class="device-meta-label">I/O Summary</div>
                <div class="device-meta-value">relays: ${escapeHtml(d.relay_count)} | buttons: ${escapeHtml(d.button_count)}</div>
                <div class="meta">power_restore: ${escapeHtml(d.power_restore_mode || "-")}</div>
              </div>
            </div>

            <div class="device-main-grid">
              <section class="device-block">
                <div class="device-block-title">Relay Controls</div>
                <div class="relay-grid">
                  ${relayControls || '<div class="muted">No relay channels reported.</div>'}
                </div>
                <div class="device-action-row">
                  <button data-relay-all="${escapeHtml(d.id)}:on">All ON</button>
                  <button data-relay-all="${escapeHtml(d.id)}:off" class="secondary">All OFF</button>
                </div>
              </section>

              <section class="device-block">
                <div class="device-block-title">Button Mapping</div>
                ${buttonStates}
                ${admin ? inputEditor : '<div class="muted">Button mapping edit is admin only.</div>'}
                ${admin ? `
                <div class="device-action-row">
                  <button data-save-io="${escapeHtml(d.id)}" class="secondary">Save I/O</button>
                </div>` : ""}
              </section>

              <section class="device-block">
                <div class="device-block-title">Connectivity Mode</div>
                ${connectivityEditor}
                <div class="device-action-row">
                  <button data-save-conn="${escapeHtml(d.id)}" class="secondary" ${(admin || d.is_owner) ? "" : "disabled"}>Save Connectivity</button>
                </div>
              </section>
            </div>

            <div class="device-footer-grid">
              <section class="device-block">
                <div class="device-block-title">Recent Device Events</div>
                <div class="device-event">
                  <div><strong>Last action</strong></div>
                  <div>${escapeHtml(summarizeLastAction(d))}</div>
                  <div><strong>Last input</strong></div>
                  <div>${escapeHtml(summarizeLastInputEvent(d))}</div>
                </div>
              </section>

              <section class="device-block">
                <div class="device-block-title">Device Actions</div>
                <div class="device-action-row">
                  <button data-rotate-token="${escapeHtml(d.id)}" class="warn">Rotate Token</button>
                  <button data-release-device="${escapeHtml(d.id)}" class="danger">Release</button>
                  <button data-delete-device="${escapeHtml(d.id)}" class="danger">Delete</button>
                  ${d.claim_code ? `<button data-claim-code="${escapeHtml(d.claim_code)}" class="secondary">Claim This Code</button>` : ""}
                </div>
              </section>
            </div>
          </article>
        `;
      }).join("");

      $("devicesTable").innerHTML = `<div class="devices-list">${cards}</div>`;
    }

    function renderSigningKeys(keys) {
      $("signingKeysTable").innerHTML = `
        <table>
          <thead><tr><th>Key ID</th><th>Status</th><th>Created</th><th>Rotated</th></tr></thead>
          <tbody>
            ${keys.map((k) => `<tr><td class="code">${k.key_id}</td><td>${k.status}</td><td>${escapeHtml(formatIsoWithOffset(k.created_at))}</td><td>${escapeHtml(formatIsoWithOffset(k.rotated_at))}</td></tr>`).join("")}
          </tbody>
        </table>
      `;
    }

    function renderReleases(releases) {
      state.releases = releases;
      $("releasesTable").innerHTML = `
        <table>
          <thead><tr><th>Version</th><th>Security</th><th>Channel</th><th>Key IDs</th><th>Expires</th><th>Actions</th></tr></thead>
          <tbody>
            ${releases.map((r) => `
              <tr>
                <td>${r.version}</td>
                <td>${r.security_version}</td>
                <td>${r.channel}</td>
                <td><div class="code">active:${r.verification_key_id || "-"}<br/>next:${r.next_verification_key_id || "-"}</div></td>
                <td>${escapeHtml(formatIsoWithOffset(r.expires_at))}</td>
                <td>
                  <button data-verify-release="${r.id}" class="secondary">Verify</button>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;
    }

    function renderBackupRuns(runs) {
      $("backupRunsTable").innerHTML = `
        <table>
          <thead><tr><th>Operation</th><th>Status</th><th>Started</th><th>Finished</th><th>Backup Path</th><th>Error</th></tr></thead>
          <tbody>
            ${runs.map((r) => `
              <tr>
                <td>${r.operation}</td>
                <td>${r.status}</td>
                <td>${escapeHtml(formatIsoWithOffset(r.started_at))}</td>
                <td>${escapeHtml(formatIsoWithOffset(r.finished_at))}</td>
                <td class="code">${r.backup_path || "-"}</td>
                <td>${r.error_message || "-"}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;
    }

    function renderAudit(rows) {
      $("auditTable").innerHTML = `
        <table>
          <thead><tr><th>Time</th><th>Source</th><th>Action</th><th>Device</th><th>User</th><th>Details</th></tr></thead>
          <tbody>
            ${rows.map((r) => `
              <tr>
                <td>${escapeHtml(formatIsoWithOffset(r.created_at))}</td>
                <td>${r.source || "-"}</td>
                <td>${r.action}</td>
                <td>${r.device_uid || "-"}</td>
                <td>${r.user_email || "-"}</td>
                <td class="code">${JSON.stringify(r.details || {})}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;
    }

    async function loadOverview() {
      if (!isAdminUser()) {
        return;
      }
      const overview = await api("/api/v1/admin/overview", { method: "GET" });
      renderKpis(overview);
    }

    async function loadUsers() {
      if (!isAdminUser()) {
        state.users = [];
        renderUsers([]);
        return;
      }
      const users = await api("/api/v1/admin/users", { method: "GET" });
      state.users = users;
      renderUsers(users);
    }

    async function loadDevices() {
      const path = isAdminUser() ? "/api/v1/admin/devices" : "/api/v1/devices";
      const devices = await api(path, { method: "GET" });

      const previousStatesByUid = new Map();
      for (const device of state.devices || []) {
        if (!device || typeof device.device_uid !== "string") {
          continue;
        }
        if (!device.button_states || typeof device.button_states !== "object" || Array.isArray(device.button_states)) {
          continue;
        }
        previousStatesByUid.set(device.device_uid, { ...device.button_states });
      }

      for (const device of devices) {
        if (!device || typeof device.device_uid !== "string") {
          continue;
        }
        const cachedStates = previousStatesByUid.get(device.device_uid);
        if (cachedStates) {
          device.button_states = { ...cachedStates };
        }
        initializeDeviceButtonStates(device);
      }

      state.devices = devices;
      renderDevices(devices);
    }

    async function loadOta() {
      if (!isAdminUser()) {
        return;
      }
      const [keys, releases] = await Promise.all([
        api("/api/v1/ota/signing-keys", { method: "GET" }),
        api("/api/v1/ota/releases", { method: "GET" })
      ]);
      renderSigningKeys(keys);
      renderReleases(releases);
    }

    async function loadOpsRuns() {
      if (!isAdminUser()) {
        return;
      }
      const runs = await api("/api/v1/admin/ops/backup/runs?limit=50", { method: "GET" });
      renderBackupRuns(runs);
    }

    async function loadAudit() {
      if (!isAdminUser()) {
        return;
      }
      const source = encodeURIComponent($("auditFilterSource").value || "");
      const action = encodeURIComponent($("auditFilterAction").value || "");
      const rows = await api(`/api/v1/admin/audit?limit=100&source=${source}&action=${action}`, { method: "GET" });
      renderAudit(rows);
    }

    async function loadMetrics() {
      const response = await fetch(baseUrl() + "/metrics");
      $("metricsOutput").textContent = await response.text();
    }

    async function loadAll() {
      if (isAdminUser()) {
        await Promise.all([
          loadOverview(),
          loadUsers(),
          loadDevices(),
          loadOta(),
          loadOpsRuns(),
          loadAudit(),
          loadMetrics()
        ]);
      } else {
        await Promise.all([
          loadDevices(),
          loadMetrics()
        ]);
      }
      log("Dashboard data refreshed.");
    }

    async function claimDeviceByCode(claimCode) {
      if (!claimCode || !claimCode.trim()) {
        throw new Error("Claim code is required.");
      }
      const out = await api("/api/v1/devices/claim", {
        method: "POST",
        body: JSON.stringify({ claim_code: claimCode.trim() })
      });
      $("claimCodeInput").value = "";
      log(`Claimed device: ${out.device?.device_uid || "ok"}`);
      if (isAdminUser()) {
        await Promise.all([loadDevices(), loadOverview(), loadUsers()]);
      } else {
        await loadDevices();
      }
    }

    async function login(endpoint) {
      const body = {
        email: $("email").value.trim(),
        password: $("password").value
      };
      if (!body.email || !body.password) {
        throw new Error("Email and password are required.");
      }

      const payload = endpoint === "register"
        ? { ...body, name: body.email.split("@")[0] || "admin" }
        : body;

      const out = await api(`/api/v1/auth/${endpoint}`, {
        method: "POST",
        body: JSON.stringify(payload)
      });

      state.user = out.user;
      state.accessToken = out.access_token;
      state.refreshToken = out.refresh_token;
      setAuthState();
      persistSession();
      log(`${endpoint} successful for ${state.user.email}.`);
      connectRealtime(true);
      await loadPreferences();
      await loadAll();
    }

    async function refreshToken() {
      await refreshAccessToken();
      connectRealtime();
    }

    async function logout() {
      if (state.refreshToken) {
        try {
          await rawRequest("/api/v1/auth/logout", {
            method: "POST",
            body: JSON.stringify({ refresh_token: state.refreshToken })
          });
        } catch {
          // Continue local logout even if revoke fails.
        }
      }
      stopRealtime({ silent: true });
      clearSession();
      setAuthState();
      log("Logged out.");
    }

    $("loginBtn").addEventListener("click", async () => {
      try { await login("login"); } catch (error) { log(`Login failed: ${error.message}`); }
    });
    $("registerBtn").addEventListener("click", async () => {
      try { await login("register"); } catch (error) { log(`Register failed: ${error.message}`); }
    });
    $("refreshBtn").addEventListener("click", async () => {
      try { await refreshToken(); } catch (error) { log(`Refresh failed: ${error.message}`); }
    });
    $("loadPrefsBtn").addEventListener("click", async () => {
      try { await loadPreferences(); } catch (error) { log(`Load prefs failed: ${error.message}`); }
    });
    $("savePrefsBtn").addEventListener("click", async () => {
      try { await savePreferences(); } catch (error) { log(`Save prefs failed: ${error.message}`); }
    });
    $("logoutBtn").addEventListener("click", async () => {
      try { await logout(); } catch (error) { log(`Logout failed: ${error.message}`); }
    });

    $("reloadAllBtn").addEventListener("click", async () => {
      try { await loadAll(); } catch (error) { log(`Reload failed: ${error.message}`); }
    });

    $("refreshDevicesBtn").addEventListener("click", async () => {
      try { await loadDevices(); log("Devices refreshed."); } catch (error) { log(`Devices refresh failed: ${error.message}`); }
    });

    $("claimDeviceBtn").addEventListener("click", async () => {
      try { await claimDeviceByCode($("claimCodeInput").value || ""); } catch (error) { log(`Claim failed: ${error.message}`); }
    });
    $("baseUrl").addEventListener("change", () => {
      persistSession();
      connectRealtime(true);
    });

    $("loadMetricsBtn").addEventListener("click", async () => {
      try { await loadMetrics(); log("Loaded /metrics."); } catch (error) { log(`Metrics load failed: ${error.message}`); }
    });

    $("runBackupBtn").addEventListener("click", async () => {
      try {
        const out = await api("/api/v1/admin/ops/backup/run", { method: "POST", body: "{}" });
        log(`Backup completed: ${out.backup_path}`);
        await loadOpsRuns();
      } catch (error) {
        log(`Backup failed: ${error.message}`);
      }
    });

    $("runRestoreDrillBtn").addEventListener("click", async () => {
      try {
        const backupPath = $("restorePath").value.trim();
        const out = await api("/api/v1/admin/ops/restore-drill/run", {
          method: "POST",
          body: JSON.stringify({ backup_path: backupPath || undefined })
        });
        log(`Restore drill completed in ${out.elapsed_ms} ms.`);
        await loadOpsRuns();
      } catch (error) {
        log(`Restore drill failed: ${error.message}`);
      }
    });

    $("simulateAlertsBtn").addEventListener("click", async () => {
      try {
        const out = await api("/api/v1/admin/ops/alerts/simulate", {
          method: "POST",
          body: JSON.stringify({})
        });
        const fired = (out.alerts || []).filter((x) => x.fired).length;
        log(`Alert simulation done. Fired alerts: ${fired}.`);
      } catch (error) {
        log(`Alert simulation failed: ${error.message}`);
      }
    });

    $("clearLogBtn").addEventListener("click", () => { $("log").textContent = ""; });

    $("createSigningKeyBtn").addEventListener("click", async () => {
      try {
        await api("/api/v1/ota/signing-keys", {
          method: "POST",
          body: JSON.stringify({
            key_id: $("signingKeyId").value.trim(),
            status: $("signingKeyStatus").value,
            private_key_secret_ref: $("signingSecretRef").value.trim(),
            public_key_pem: $("signingPublicPem").value
          })
        });
        log("Signing key created.");
        await loadOta();
      } catch (error) {
        log(`Create signing key failed: ${error.message}`);
      }
    });

    $("rotateSigningKeysBtn").addEventListener("click", async () => {
      try {
        const out = await api("/api/v1/ota/signing-keys/rotate", { method: "POST", body: "{}" });
        log(`Signing keys rotated. New active: ${out.active_key?.key_id || "n/a"}`);
        await loadOta();
      } catch (error) {
        log(`Rotate signing keys failed: ${error.message}`);
      }
    });

    $("uploadReleaseBtn").addEventListener("click", async () => {
      const fileInput = $("releaseBinFile");
      const firmwareFile = fileInput?.files?.[0];
      if (!firmwareFile) {
        log("Select a .bin firmware file first.");
        return;
      }

      const metadataText = $("releaseMetadataJson").value.trim();
      if (metadataText) {
        try {
          const parsed = JSON.parse(metadataText);
          if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
            throw new Error("invalid");
          }
        } catch {
          log("Metadata must be a valid JSON object.");
          return;
        }
      }

      try {
        const form = new FormData();
        form.append("firmware", firmwareFile, firmwareFile.name);

        const model = $("releaseModel").value.trim();
        const version = $("releaseVersion").value.trim();
        const channel = $("releaseChannel").value.trim();
        const expiresAt = $("releaseExpiresAt").value.trim();
        const securityVersion = $("releaseSecurityVersion").value.trim();

        if (model) form.append("model", model);
        if (version) form.append("version", version);
        if (channel) form.append("channel", channel);
        if (expiresAt) form.append("expires_at", expiresAt);
        if (securityVersion) form.append("security_version", securityVersion);
        form.append("is_active", "true");
        form.append("auto_sign", "true");
        form.append("metadata", metadataText || JSON.stringify({ created_from: "dashboard_upload" }));

        const out = await api("/api/v1/ota/releases/upload", {
          method: "POST",
          body: form
        });

        log(
          `OTA upload created release ${out.model} ${out.version} (${out.channel}) sha=${String(
            out.sha256 || ""
          ).slice(0, 12)}...`
        );
        await loadOta();
      } catch (error) {
        log(`Upload release failed: ${error.message}`);
      }
    });

    $("createReleaseBtn").addEventListener("click", async () => {
      try {
        await api("/api/v1/ota/releases", {
          method: "POST",
          body: JSON.stringify({
            model: $("releaseModel").value.trim(),
            version: $("releaseVersion").value.trim(),
            security_version: Number($("releaseSecurityVersion").value),
            channel: $("releaseChannel").value,
            url: $("releaseUrl").value.trim(),
            size_bytes: Number($("releaseSizeBytes").value),
            sha256: $("releaseSha").value.trim(),
            expires_at: $("releaseExpiresAt").value.trim(),
            is_active: true,
            metadata: { created_from: "dashboard" },
            auto_sign: true
          })
        });
        log("OTA release created and signed.");
        await loadOta();
      } catch (error) {
        log(`Create release failed: ${error.message}`);
      }
    });

    $("releasesTable").addEventListener("click", async (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const verifyId = target.getAttribute("data-verify-release");
      if (!verifyId) return;
      try {
        const out = await api(`/api/v1/ota/releases/${encodeURIComponent(verifyId)}/verify`, { method: "GET" });
        log(`Release ${verifyId} verification: ${out.ok ? "OK" : `FAILED (${out.reason})`}`);
      } catch (error) {
        log(`Release verify failed: ${error.message}`);
      }
    });

    $("usersTable").addEventListener("click", async (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const userDeleteId = target.getAttribute("data-user-delete");
      const userId = target.getAttribute("data-user-save");

      try {
        if (userDeleteId) {
          if (!window.confirm(`Delete user ${userDeleteId}? This action cannot be undone.`)) {
            return;
          }
          await api(`/api/v1/admin/users/${encodeURIComponent(userDeleteId)}`, {
            method: "DELETE"
          });
          log(`User ${userDeleteId} deleted.`);
          await Promise.all([loadUsers(), loadDevices(), loadOverview()]);
          return;
        }

        if (!userId) return;

        const name = document.querySelector(`[data-user-name=\"${userId}\"]`)?.value || "";
        const role = document.querySelector(`[data-user-role=\"${userId}\"]`)?.value || "user";
        const isActive = Boolean(document.querySelector(`[data-user-active=\"${userId}\"]`)?.checked);
        await api(`/api/v1/admin/users/${encodeURIComponent(userId)}`, {
          method: "PATCH",
          body: JSON.stringify({ name, role, is_active: isActive })
        });
        log(`User ${userId} updated.`);
        await loadUsers();
      } catch (error) {
        log(`User update failed: ${error.message}`);
      }
    });

    $("devicesTable").addEventListener("click", async (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;

      const relayCmd = target.getAttribute("data-relay");
      const relayAll = target.getAttribute("data-relay-all");
      const saveIo = target.getAttribute("data-save-io");
      const saveConn = target.getAttribute("data-save-conn");
      const rotateToken = target.getAttribute("data-rotate-token");
      const releaseDevice = target.getAttribute("data-release-device");
      const deleteDevice = target.getAttribute("data-delete-device");
      const claimCode = target.getAttribute("data-claim-code");

      try {
        if (relayCmd) {
          const [deviceId, idx, action] = relayCmd.split(":");
          const relayPath = isAdminUser()
            ? `/api/v1/admin/devices/${encodeURIComponent(deviceId)}/relays/${encodeURIComponent(idx)}`
            : `/api/v1/devices/${encodeURIComponent(deviceId)}/relays/${encodeURIComponent(idx)}`;
          await withDeviceActionLock(deviceId, async () => {
            await api(relayPath, {
              method: "POST",
              body: JSON.stringify({ action })
            });
          });
          log(`Relay command sent: ${deviceId} r${idx} ${action}`);
          await loadDevices();
          return;
        }

        if (relayAll) {
          const [deviceId, action] = relayAll.split(":");
          const relayAllPath = isAdminUser()
            ? `/api/v1/admin/devices/${encodeURIComponent(deviceId)}/relays/all`
            : `/api/v1/devices/${encodeURIComponent(deviceId)}/relays/all`;
          await withDeviceActionLock(deviceId, async () => {
            await api(relayAllPath, {
              method: "POST",
              body: JSON.stringify({ action })
            });
          });
          log(`All-relay command sent: ${deviceId} ${action}`);
          await loadDevices();
          return;
        }

        if (saveIo) {
          if (!isAdminUser()) {
            throw new Error("forbidden: Insufficient role.");
          }
          const device = state.devices.find((item) => item && item.id === saveIo);
          if (!device) {
            throw new Error("Device not found in dashboard state.");
          }

          const inputConfig = collectInputConfigFromEditor(device);
          await api(`/api/v1/admin/devices/${encodeURIComponent(saveIo)}`, {
            method: "PATCH",
            body: JSON.stringify({ input_config: inputConfig })
          });
          log(`I/O config saved: ${saveIo}`);
          await loadDevices();
          return;
        }

        if (saveConn) {
          const device = state.devices.find((item) => item && item.id === saveConn);
          if (!device) {
            throw new Error("Device not found in dashboard state.");
          }
          if (!isAdminUser() && !device.is_owner) {
            throw new Error("forbidden: Only owner/admin can edit connectivity.");
          }

          const connectivity = collectConnectivityConfigFromEditor(device);
          const mergedConfig = mergeConnectivityConfig(device, connectivity);
          const patchPath = isAdminUser()
            ? `/api/v1/admin/devices/${encodeURIComponent(saveConn)}`
            : `/api/v1/devices/${encodeURIComponent(saveConn)}`;
          await api(patchPath, {
            method: "PATCH",
            body: JSON.stringify({ config: mergedConfig })
          });
          log(`Connectivity config saved: ${saveConn} (${connectivity.mode})`);
          await loadDevices();
          return;
        }

        if (rotateToken) {
          const rotatePath = isAdminUser()
            ? `/api/v1/admin/devices/${encodeURIComponent(rotateToken)}/token/rotate`
            : `/api/v1/devices/${encodeURIComponent(rotateToken)}/token/rotate`;
          const out = await api(rotatePath, {
            method: "POST",
            body: "{}"
          });
          log(`Token rotated for ${rotateToken}: ${out.device_token}`);
          return;
        }

        if (releaseDevice) {
          const releasePath = isAdminUser()
            ? `/api/v1/admin/devices/${encodeURIComponent(releaseDevice)}/release`
            : `/api/v1/devices/${encodeURIComponent(releaseDevice)}/release`;
          const out = await api(releasePath, {
            method: "POST",
            body: "{}"
          });
          log(`Device ${releaseDevice} released. Claim code: ${out.claim_code}`);
          await Promise.all([loadDevices(), loadOverview()]);
          return;
        }

        if (deleteDevice) {
          if (!window.confirm(`Delete device ${deleteDevice}? This action cannot be undone.`)) {
            return;
          }
          await api(`/api/v1/devices/${encodeURIComponent(deleteDevice)}`, {
            method: "DELETE"
          });
          log(`Device deleted: ${deleteDevice}`);
          await Promise.all([loadDevices(), loadOverview(), loadUsers()]);
          return;
        }

        if (claimCode) {
          await claimDeviceByCode(claimCode);
          return;
        }
      } catch (error) {
        log(`Device action failed: ${error.message}`);
      }
    });

    $("devicesTable").addEventListener("change", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;

      const typeKey = target.getAttribute("data-io-type");
      if (typeKey) {
        syncInputRowControls(typeKey);
        return;
      }

      const linkedKey = target.getAttribute("data-io-linked");
      if (linkedKey) {
        syncInputRowControls(linkedKey);
        return;
      }

      const connModeKey = target.getAttribute("data-conn-mode");
      if (connModeKey) {
        syncConnectivityControls(connModeKey);
      }
    });

    $("loadAuditBtn").addEventListener("click", async () => {
      try { await loadAudit(); log("Audit list refreshed."); } catch (error) { log(`Audit load failed: ${error.message}`); }
    });

    $("clearAuditBtn").addEventListener("click", async () => {
      const source = ($("auditFilterSource").value || "").trim();
      const action = ($("auditFilterAction").value || "").trim();
      const scope = source || action
        ? `source='${source || "*"}', action='${action || "*"}'`
        : "ALL audit entries";

      if (!window.confirm(`Clear ${scope}? This cannot be undone.`)) {
        return;
      }

      try {
        const qs = new URLSearchParams();
        if (source) qs.set("source", source);
        if (action) qs.set("action", action);
        const path = qs.toString()
          ? `/api/v1/admin/audit?${qs.toString()}`
          : "/api/v1/admin/audit";
        const out = await api(path, { method: "DELETE" });
        log(`Audit cleared. Deleted ${out.deleted || 0} row(s).`);
        await Promise.all([loadAudit(), loadOverview()]);
      } catch (error) {
        log(`Clear audit failed: ${error.message}`);
      }
    });

    loadCollapsedCards();
    setupCollapsibleCards();
    restoreSession();
    setAuthState();

    if (state.user && state.refreshToken) {
      log(`Restored session for ${state.user.email}.`);
      connectRealtime();
      (async () => {
        try {
          await loadPreferences();
          await loadAll();
        } catch (error) {
          log(`Auto-load failed: ${error.message}`);
        }
      })();
    } else {
      log("Ready. Login with admin credentials to load live ops data.");
    }
  </script>
</body>
</html>
